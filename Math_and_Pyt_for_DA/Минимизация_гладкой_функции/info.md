Задание по программированию: Оптимизация в Python: глобальная оптимизация и оптимизация негладкой функции

	Задача 1. Минимизация гладкой функции
		1. Рассмотрим все ту же функцию из задания по линейной алгебре: 
		f(x) = sin(x / 5) * exp(x / 10) + 5 * exp(-x / 2), но теперь уже на промежутке [1, 30]
		
		2. В первом задании будем искать минимум этой функции на заданном промежутке с помощью scipy.optimize. 
		Разумеется, в дальнейшем вы будете использовать методы оптимизации для более сложных функций, 
		а f(x) мы рассмотрим как удобный учебный пример.
		
		3. Напишите на Питоне функцию, вычисляющую значение f(x) по известному x. Будьте внимательны: 
		не забывайте про то, что по умолчанию в питоне целые числа делятся нацело, и о том, что функции sin 
		и exp нужно импортировать из модуля math.
		
		4. Изучите примеры использования scipy.optimize.minimize в документации Scipy (см. "Материалы")
		
		5. Попробуйте найти минимум, используя стандартные параметры в функции scipy.optimize.minimize 
		(т.е. задав только функцию и начальное приближение). Попробуйте менять начальное приближение и 
		изучить, меняется ли результат.
		
		6. Укажите в scipy.optimize.minimize в качестве метода BFGS (один из самых точных в большинстве 
		случаев градиентных методов оптимизации), запустите из начального приближения x=2. Градиент функции 
		при этом указывать не нужно – он будет оценен численно. Полученное значение функции в точке минимума
		- ваш первый ответ по заданию 1, его надо записать с точностью до 2 знака после запятой.
		
		7. Теперь измените начальное приближение на x=30. Значение функции в точке минимума - ваш второй 
		ответ по заданию 1, его надо записать через пробел после первого, с точностью до 2 знака после запятой.
		
		8. Стоит обдумать полученный результат. Почему ответ отличается в зависимости от начального приближения? 
		Если нарисовать график функции (например, как это делалось в видео, где мы знакомились с Numpy, Scipy и 
		Matplotlib), можно увидеть, в какие именно минимумы мы попали. В самом деле, градиентные методы обычно не 
		решают задачу глобальной оптимизации, поэтому результаты работы ожидаемые и вполне корректные.